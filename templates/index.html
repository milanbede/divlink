<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bible Terminal</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div id="terminal">
        <div id="output">
            <div>Welcome to Bible Terminal!</div>
            <div>Type your query below and press Enter.</div>
            <div>&nbsp;</div>
        </div>
        <div class="prompt-line">
            <span class="prompt">&gt;</span>
            <input type="text" id="commandInput" autofocus><span id="customCursor"></span>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const commandInput = document.getElementById('commandInput');
            const outputDiv = document.getElementById('output');
            const customCursor = document.getElementById('customCursor');
            const textMeasurer = document.getElementById('textMeasurer'); // Get reference to the new span
            const promptLine = commandInput.parentElement; // Get reference to the prompt line container

            // Canvas related variables are no longer needed
            // const getTextWidthCanvas = document.createElement("canvas");
            // const getTextWidthContext = getTextWidthCanvas.getContext("2d");

            function updateCursorPosition() {
                if (document.activeElement !== commandInput) {
                    customCursor.style.visibility = 'hidden';
                    return;
                }
                customCursor.style.visibility = 'visible';

                const textBeforeCursor = commandInput.value.substring(0, commandInput.selectionStart);
                const styles = window.getComputedStyle(commandInput);

                // Apply necessary styles from input to the measurer span
                textMeasurer.style.fontFamily = styles.fontFamily;
                textMeasurer.style.fontSize = styles.fontSize;
                textMeasurer.style.fontWeight = styles.fontWeight;
                textMeasurer.style.fontStyle = styles.fontStyle;
                textMeasurer.style.fontVariant = styles.fontVariant;
                textMeasurer.style.letterSpacing = styles.letterSpacing;
                textMeasurer.style.wordSpacing = styles.wordSpacing;
                // textMeasurer.style.paddingLeft = styles.paddingLeft; // Usually not needed if measuring text part only
                // textMeasurer.style.paddingRight = styles.paddingRight;

                // Set the text content to measure
                textMeasurer.textContent = textBeforeCursor;

                const textWidth = textMeasurer.offsetWidth;

                customCursor.style.left = `${commandInput.offsetLeft + textWidth}px`;
                customCursor.style.top = `${commandInput.offsetTop}px`;
                customCursor.style.height = `${commandInput.offsetHeight}px`;
            }

            commandInput.addEventListener('focus', updateCursorPosition);
            commandInput.addEventListener('blur', () => {
                customCursor.style.visibility = 'hidden';
            });
            commandInput.addEventListener('input', updateCursorPosition);
            commandInput.addEventListener('click', updateCursorPosition);

            // For keys that move the caret (arrows, home, end, etc.) or modify text.
            // Use a slight delay to ensure caret position is updated before measuring.
            commandInput.addEventListener('keydown', (event) => {
                // Let the Enter key be handled by its own specific listener.
                // Also, ignore modifier keys if pressed alone, as they don't move the caret.
                if (event.key === 'Enter' || event.key === 'Shift' || event.key === 'Control' || event.key === 'Alt' || event.key === 'Meta') {
                    // If it's Enter, it's handled by the other listener.
                    // If it's just a modifier, the caret hasn't moved yet.
                    return;
                }
                // For other keys (arrows, backspace, delete, characters), update position after default action.
                setTimeout(updateCursorPosition, 0);
            });
             // Call once on load in case of autofocus
            if (document.activeElement === commandInput) {
                updateCursorPosition();
            }


            commandInput.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const command = commandInput.value.trim();
                    if (command) {
                        // Display command in output
                        const commandElement = document.createElement('div');
                        commandElement.className = 'echoed-command-line'; // Add class for flex styling
                        commandElement.innerHTML = `<span class="prompt-echo">&gt;</span><span class="echoed-command-text">${escapeHtml(command)}</span>`;
                        outputDiv.appendChild(commandElement);

                        // Hide the entire prompt line during response typing
                        promptLine.style.visibility = 'hidden';

                        fetch('/query', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ query: command }),
                        })
                        .then(response => {
                            if (!response.ok) {
                                // Try to parse error from backend if available, then throw
                                return response.json().then(errData => {
                                    throw new Error(errData.error || `Server error: ${response.status}`);
                                }).catch(() => {
                                    // Fallback if error response is not JSON or no 'error' field
                                    throw new Error(`Server error: ${response.status}`);
                                });
                            }
                            return response.json();
                        })
                        .then(data => {
                            const responseText = data.response || "Received no specific response.";
                            typeResponse(responseText, outputDiv, () => {
                                // This callback runs after typing is complete
                                outputDiv.appendChild(document.createElement('br'));
                                commandInput.value = '';
                                promptLine.style.visibility = 'visible';
                                outputDiv.scrollTop = outputDiv.scrollHeight;
                                commandInput.focus();
                                updateCursorPosition();
                            });
                        })
                        .catch(error => {
                            console.error('Fetch Error:', error);
                            const errorText = `Error: ${escapeHtml(error.message)}`;
                            typeResponse(errorText, outputDiv, () => {
                                // This callback runs after typing is complete
                                outputDiv.appendChild(document.createElement('br'));
                                commandInput.value = '';
                                promptLine.style.visibility = 'visible';
                                outputDiv.scrollTop = outputDiv.scrollHeight;
                                commandInput.focus();
                                updateCursorPosition();
                            });
                        });
                    } else {
                        // Handle empty command: echo an empty prompt and add a line break
                        const commandElement = document.createElement('div');
                        commandElement.innerHTML = `<span class="prompt-echo">&gt;</span>&nbsp;`; // Echo empty prompt with a non-breaking space
                        outputDiv.appendChild(commandElement);
                        outputDiv.appendChild(document.createElement('br')); // Add a line break

                        commandInput.value = ''; // Ensure it's cleared
                        outputDiv.scrollTop = outputDiv.scrollHeight; // Scroll to bottom
                        commandInput.focus(); // Keep focus on input
                        updateCursorPosition(); // Explicitly update cursor after clearing and focusing
                    }
                }
            });

            function typeResponse(text, container, callback) {
                const responseElement = document.createElement('div');
                responseElement.className = 'llm-response-text'; // Add class for styling
                container.appendChild(responseElement);
                let i = 0;
                const typingSpeed = 30; // Milliseconds per character (adjust for desired speed)

                function typeChar() {
                    if (i < text.length) {
                        responseElement.textContent += text.charAt(i);
                        i++;
                        // Optional: Add a subtle flicker or effect per character here for more CRT feel
                        setTimeout(typeChar, typingSpeed);
                    } else {
                        // Typing finished
                        if (callback) {
                            callback();
                        }
                    }
                }
                typeChar(); // Start typing
            }

            function escapeHtml(unsafe) {
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

            // Focus on input when clicking anywhere in the terminal
            document.getElementById('terminal').addEventListener('click', () => {
                commandInput.focus();
            });
        });
    </script>
    <span id="textMeasurer"></span> <!-- Add the measurer span here -->
</body>
</html>
