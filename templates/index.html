<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bible Terminal</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div id="terminal">
        <div id="output">
        </div>
        <div class="prompt-line">
            <span class="username">seeker</span><span class="prompt">&gt;</span>
            <input type="text" id="commandInput" autofocus><span id="customCursor"></span>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const commandInput = document.getElementById('commandInput');
            const outputDiv = document.getElementById('output');
            const terminalDiv = document.getElementById('terminal');
            const customCursor = document.getElementById('customCursor');
            const textMeasurer = document.getElementById('textMeasurer');
            const promptLine = commandInput.parentElement;

            // Wrap references like "Sirach 1:2-7" in a BibleGateway link
            function linkifyVerses(text) {
                const version = 'NRSVCE';
                return text.replace(/(\b(?:[1-3]\s)?[A-Za-z][\w\s']*?)\s(\d+:\d+(?:[-â€“]\d+)?)/g, (match, book, verses) => {
                    const search = encodeURIComponent(`${book} ${verses}`);
                    const url = `https://www.biblegateway.com/passage/?search=${search}&version=${version}`;
                    return `<a href="${url}" target="_blank" rel="noopener noreferrer">${match}</a>`;
                });
            }

            let idleTimerId;
            const idleTimeoutDuration = 60000;
            let hasPsalmBeenShown = false;

            let scrollIntervalId = null;
            const scrollStepAmount = 3;
            const scrollIntervalTime = 16;

            function ensureScrolling() {
                if (!scrollIntervalId && terminalDiv.scrollHeight > terminalDiv.clientHeight &&
                    terminalDiv.scrollTop < (terminalDiv.scrollHeight - terminalDiv.clientHeight)) {

                    scrollIntervalId = setInterval(() => {
                        const currentTargetScrollTop = terminalDiv.scrollHeight - terminalDiv.clientHeight;
                        if (terminalDiv.scrollTop < currentTargetScrollTop) {
                            terminalDiv.scrollTop += scrollStepAmount;
                            if (terminalDiv.scrollTop >= currentTargetScrollTop) {
                                terminalDiv.scrollTop = currentTargetScrollTop;
                                clearInterval(scrollIntervalId);
                                scrollIntervalId = null;
                            }
                        } else {
                            terminalDiv.scrollTop = currentTargetScrollTop;
                            clearInterval(scrollIntervalId);
                            scrollIntervalId = null;
                        }
                    }, scrollIntervalTime);
                }
            }

            function updateCursorPosition() {
                if (document.activeElement !== commandInput) {
                    customCursor.style.visibility = 'hidden';
                    return;
                }
                customCursor.style.visibility = 'visible';

                const textBeforeCursor = commandInput.value.substring(0, commandInput.selectionStart);
                const styles = window.getComputedStyle(commandInput);

                textMeasurer.style.fontFamily = styles.fontFamily;
                textMeasurer.style.fontSize = styles.fontSize;
                textMeasurer.style.fontWeight = styles.fontWeight;
                textMeasurer.style.fontStyle = styles.fontStyle;
                textMeasurer.style.fontVariant = styles.fontVariant;
                textMeasurer.style.letterSpacing = styles.letterSpacing;
                textMeasurer.style.wordSpacing = styles.wordSpacing;

                textMeasurer.textContent = textBeforeCursor;
                const textWidth = textMeasurer.offsetWidth;

                customCursor.style.left = `${commandInput.offsetLeft + textWidth}px`;
                customCursor.style.top = `${commandInput.offsetTop}px`;
                customCursor.style.height = `${commandInput.offsetHeight}px`;
            }

            commandInput.addEventListener('focus', () => {
                updateCursorPosition();
                resetIdleTimer();
            });
            commandInput.addEventListener('blur', () => {
                customCursor.style.visibility = 'hidden';
                resetIdleTimer();
            });
            commandInput.addEventListener('input', () => {
                updateCursorPosition();
                resetIdleTimer();
            });
            commandInput.addEventListener('click', () => {
                updateCursorPosition();
                resetIdleTimer();
            });
            commandInput.addEventListener('keydown', (event) => {
                if (['Enter','Shift','Control','Alt','Meta'].includes(event.key)) return;
                setTimeout(updateCursorPosition, 0);
            });
            commandInput.addEventListener('keyup', (event) => {
                const navKeys = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','PageUp','PageDown'];
                if (navKeys.includes(event.key)) resetIdleTimer();
            });

            if (document.activeElement === commandInput) {
                updateCursorPosition();
            }

            function showRandomPsalm() {
                if (hasPsalmBeenShown) return;
                hasPsalmBeenShown = true;
                clearTimeout(idleTimerId);
                promptLine.style.visibility = 'hidden';

                fetch('/random_psalm')
                    .then(r => {
                        if (!r.ok) {
                            return r.json().then(errData => { throw new Error(errData.error || `Server error: ${r.status}`); })
                                       .catch(() => { throw new Error(`Server error: ${r.status}`); });
                        }
                        return r.json();
                    })
                    .then(data => {
                        const psalmText = data.response || "Could not retrieve a Psalm at this moment.";
                        typeResponse(linkifyVerses(psalmText), outputDiv, data.score, () => {
                            outputDiv.appendChild(document.createElement('br'));
                            promptLine.style.visibility = 'visible';
                            ensureScrolling();
                            commandInput.focus();
                            updateCursorPosition();
                        });
                    })
                    .catch(error => {
                        console.error('Error fetching random Psalm:', error);
                        const errorElement = document.createElement('div');
                        errorElement.textContent = `Error: Could not load a Psalm. ${error.message}`;
                        errorElement.style.color = 'red';
                        outputDiv.appendChild(errorElement);
                        outputDiv.appendChild(document.createElement('br'));
                        promptLine.style.visibility = 'visible';
                        ensureScrolling();
                        commandInput.focus();
                        updateCursorPosition();
                    });
            }

            function resetIdleTimer() {
                if (hasPsalmBeenShown) return;
                clearTimeout(idleTimerId);
                const inputIsEmpty = commandInput.value.trim() === '';
                const inputIsActive = document.activeElement === commandInput;
                const uiReady = promptLine.style.visibility !== 'hidden';
                if (inputIsEmpty && inputIsActive && uiReady) {
                    idleTimerId = setTimeout(showRandomPsalm, idleTimeoutDuration);
                }
            }

            resetIdleTimer();

            commandInput.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    clearTimeout(idleTimerId);
                    event.preventDefault();
                    const command = commandInput.value.trim();
                    if (command) {
                        const commandElement = document.createElement('div');
                        commandElement.className = 'echoed-command-line';
                        commandElement.innerHTML = `<span class="username-echo">seeker</span><span class="prompt-echo">&gt;</span><span class="echoed-command-text">${escapeHtml(command)}</span>`;
                        outputDiv.appendChild(commandElement);
                        ensureScrolling();
                        promptLine.style.visibility = 'hidden';

                        fetch('/query', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ query: command }),
                        })
                        .then(r => {
                            if (!r.ok) {
                                return r.json().then(errData => { throw new Error(errData.error || `Server error: ${r.status}`); })
                                           .catch(() => { throw new Error(`Server error: ${r.status}`); });
                            }
                            return r.json();
                        })
                        .then(data => {
                            const responseText = data.response || "Received no specific response.";
                            const score = data.score;
                            typeResponse(linkifyVerses(responseText), outputDiv, score, () => {
                                outputDiv.appendChild(document.createElement('br'));
                                commandInput.value = '';
                                promptLine.style.visibility = 'visible';
                                ensureScrolling();
                                commandInput.focus();
                                updateCursorPosition();
                            });
                        })
                        .catch(error => {
                            console.error('Fetch Error:', error);
                            const errorText = `Error: ${escapeHtml(error.message)}`;
                            typeResponse(errorText, outputDiv, null, () => {
                                outputDiv.appendChild(document.createElement('br'));
                                commandInput.value = '';
                                promptLine.style.visibility = 'visible';
                                ensureScrolling();
                                commandInput.focus();
                                updateCursorPosition();
                            });
                        });
                    } else {
                        const commandElement = document.createElement('div');
                        commandElement.className = 'echoed-command-line';
                        commandElement.innerHTML = `<span class="username-echo">seeker</span><span class="prompt-echo">&gt;</span>&nbsp;`;
                        outputDiv.appendChild(commandElement);
                        outputDiv.appendChild(document.createElement('br'));
                        ensureScrolling();
                        commandInput.value = '';
                        commandInput.focus();
                        updateCursorPosition();
                    }
                }
            });

            function typeResponse(text, container, score, callback) {
                const baseResponseElement = document.createElement('div');
                baseResponseElement.className = 'llm-response-text';
                if (score === 20) {
                    baseResponseElement.classList.add('perfect-score-text');
                }
                container.appendChild(baseResponseElement);

                let currentTargetElement = baseResponseElement;
                let i = 0;
                const typingSpeed = 30;

                function typeChar() {
                    if (i < text.length) {
                        let consumedLength = 1;
                        const c = text.charAt(i);

                        // anchor tags
                        if (c === '<' && text.substring(i).startsWith('<a ')) {
                            const endTagIndex = text.indexOf('>', i);
                            if (endTagIndex !== -1) {
                                const tagText = text.substring(i, endTagIndex + 1);
                                const hrefMatch = tagText.match(/href="([^"]+)"/);
                                const hrefValue = hrefMatch ? hrefMatch[1] : '';
                                const newAnchor = document.createElement('a');
                                newAnchor.href = hrefValue;
                                newAnchor.target = '_blank';
                                newAnchor.rel = 'noopener noreferrer';
                                currentTargetElement.appendChild(newAnchor);
                                currentTargetElement = newAnchor;
                                consumedLength = tagText.length;
                            }
                        } else if (c === '<' && text.substring(i).startsWith('</a>')) {
                            if (currentTargetElement.parentElement && currentTargetElement.tagName.toLowerCase() === 'a') {
                                currentTargetElement = currentTargetElement.parentElement;
                            } else {
                                baseResponseElement.innerHTML += '</a>';
                            }
                            consumedLength = 4;
                        } else {
                            const openDivine = '<span class="divine-name">';
                            const closeDivine = '</span>';
                            const openEm = '<em>';
                            const closeEm = '</em>';

                            if (c === '<' && text.substring(i).startsWith(openDivine)) {
                                const newSpan = document.createElement('span');
                                newSpan.className = 'divine-name';
                                currentTargetElement.appendChild(newSpan);
                                currentTargetElement = newSpan;
                                consumedLength = openDivine.length;
                            } else if (c === '<' && text.substring(i).startsWith(closeDivine)) {
                                if (currentTargetElement.parentElement && currentTargetElement.className === 'divine-name') {
                                    currentTargetElement = currentTargetElement.parentElement;
                                } else {
                                    baseResponseElement.innerHTML += closeDivine;
                                }
                                consumedLength = closeDivine.length;
                            } else if (c === '<' && text.substring(i).startsWith(openEm)) {
                                const newEm = document.createElement('em');
                                currentTargetElement.appendChild(newEm);
                                currentTargetElement = newEm;
                                consumedLength = openEm.length;
                            } else if (c === '<' && text.substring(i).startsWith(closeEm)) {
                                if (currentTargetElement.parentElement && currentTargetElement.tagName.toLowerCase() === 'em') {
                                    currentTargetElement = currentTargetElement.parentElement;
                                } else {
                                    baseResponseElement.innerHTML += closeEm;
                                }
                                consumedLength = closeEm.length;
                            } else {
                                currentTargetElement.appendChild(document.createTextNode(c));
                            }
                        }

                        i += consumedLength;
                        terminalDiv.scrollTop = terminalDiv.scrollHeight;
                        setTimeout(typeChar, typingSpeed);
                    } else {
                        if (callback) callback();
                    }
                }

                typeChar();
            }

            function escapeHtml(unsafe) {
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

            document.getElementById('terminal').addEventListener('click', (event) => {
                if (event.target !== commandInput) {
                    commandInput.focus();
                }
            });
            document.getElementById('terminal').addEventListener('click', resetIdleTimer);

            // Pause blinking & hide the custom cursor whenever any text selection is active,
            // and resume blinking once the selection clears.
            document.addEventListener('selectionchange', () => {
                const selection = window.getSelection();
                if (!selection.isCollapsed) {
                    customCursor.style.visibility = 'hidden';
                    customCursor.style.animationPlayState = 'paused';
                } else {
                    customCursor.style.animationPlayState = 'running';
                    updateCursorPosition();
                }
            });
        });
    </script>
    <span id="textMeasurer"></span>
</body>
</html>
