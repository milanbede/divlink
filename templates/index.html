<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bible Terminal</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div id="terminal">
        <div id="output">
        </div>
        <div class="prompt-line">
            <span class="username">seeker</span><span class="prompt">&gt;</span>
            <input type="text" id="commandInput" autofocus><span id="customCursor"></span>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const commandInput = document.getElementById('commandInput');
            const outputDiv = document.getElementById('output');
            const customCursor = document.getElementById('customCursor');
            const textMeasurer = document.getElementById('textMeasurer'); // Get reference to the new span
            const promptLine = commandInput.parentElement; // Get reference to the prompt line container

            let idleTimerId;
            const idleTimeoutDuration = 60000; // 60 seconds in milliseconds
            let hasPsalmBeenShown = false;

            let scrollIntervalId = null;
            const scrollStepAmount = 3; // Pixels to scroll per step
            const scrollIntervalTime = 16; // Milliseconds per interval (approx 60fps)

            function ensureScrolling() {
                // If not already scrolling and scrolling is needed
                if (!scrollIntervalId && outputDiv.scrollHeight > outputDiv.clientHeight &&
                    outputDiv.scrollTop < (outputDiv.scrollHeight - outputDiv.clientHeight)) {

                    scrollIntervalId = setInterval(() => {
                        const targetScrollTop = outputDiv.scrollHeight - outputDiv.clientHeight;
                        if (outputDiv.scrollTop < targetScrollTop) {
                            outputDiv.scrollTop += scrollStepAmount;
                            if (outputDiv.scrollTop >= targetScrollTop) {
                                outputDiv.scrollTop = targetScrollTop; // Snap to exact bottom
                                clearInterval(scrollIntervalId);
                                scrollIntervalId = null;
                            }
                        } else {
                            // Already at or past the bottom (e.g. content shrunk or scrolled manually)
                            clearInterval(scrollIntervalId);
                            scrollIntervalId = null;
                        }
                    }, scrollIntervalTime);
                }
            }

            // Canvas related variables are no longer needed
            // const getTextWidthCanvas = document.createElement("canvas");
            // const getTextWidthContext = getTextWidthCanvas.getContext("2d");

            function updateCursorPosition() {
                if (document.activeElement !== commandInput) {
                    customCursor.style.visibility = 'hidden';
                    return;
                }
                customCursor.style.visibility = 'visible';

                const textBeforeCursor = commandInput.value.substring(0, commandInput.selectionStart);
                const styles = window.getComputedStyle(commandInput);

                // Apply necessary styles from input to the measurer span
                textMeasurer.style.fontFamily = styles.fontFamily;
                textMeasurer.style.fontSize = styles.fontSize;
                textMeasurer.style.fontWeight = styles.fontWeight;
                textMeasurer.style.fontStyle = styles.fontStyle;
                textMeasurer.style.fontVariant = styles.fontVariant;
                textMeasurer.style.letterSpacing = styles.letterSpacing;
                textMeasurer.style.wordSpacing = styles.wordSpacing;
                // textMeasurer.style.paddingLeft = styles.paddingLeft; // Usually not needed if measuring text part only
                // textMeasurer.style.paddingRight = styles.paddingRight;

                // Set the text content to measure
                textMeasurer.textContent = textBeforeCursor;

                const textWidth = textMeasurer.offsetWidth;

                customCursor.style.left = `${commandInput.offsetLeft + textWidth}px`;
                customCursor.style.top = `${commandInput.offsetTop}px`;
                customCursor.style.height = `${commandInput.offsetHeight}px`;
            }

            commandInput.addEventListener('focus', () => {
                updateCursorPosition();
                resetIdleTimer();
            });
            commandInput.addEventListener('blur', () => {
                customCursor.style.visibility = 'hidden';
                resetIdleTimer();
            });
            commandInput.addEventListener('input', () => {
                updateCursorPosition();
                resetIdleTimer();
            });
            commandInput.addEventListener('click', () => {
                updateCursorPosition();
                resetIdleTimer();
            });

            // For keys that move the caret (arrows, home, end, etc.) or modify text.
            // Use a slight delay to ensure caret position is updated before measuring.
            commandInput.addEventListener('keydown', (event) => {
                // Let the Enter key be handled by its own specific listener.
                // Also, ignore modifier keys if pressed alone, as they don't move the caret.
                if (event.key === 'Enter' || event.key === 'Shift' || event.key === 'Control' || event.key === 'Alt' || event.key === 'Meta') {
                    // If it's Enter, it's handled by the other listener.
                    // If it's just a modifier, the caret hasn't moved yet.
                    return;
                }
                // For other keys (arrows, backspace, delete, characters), update position after default action.
                setTimeout(updateCursorPosition, 0);
            });

            commandInput.addEventListener('keyup', (event) => {
                // For keys that move the cursor but don't fire 'input' (arrows, Home, End)
                // and thus wouldn't trigger resetIdleTimer via the 'input' event.
                const navigationKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'];
                if (navigationKeys.includes(event.key)) {
                    resetIdleTimer();
                }
            });

             // Call once on load in case of autofocus
            if (document.activeElement === commandInput) {
                updateCursorPosition();
            }

            function showRandomPsalm() {
                if (hasPsalmBeenShown) {
                    return;
                }
                hasPsalmBeenShown = true; // Set flag immediately
                clearTimeout(idleTimerId); // Clear timer as we are now showing it

                // Add a small visual break or message if desired before fetching
                // const thinkingElement = document.createElement('div');
                // thinkingElement.textContent = "[A moment of reflection...]";
                // outputDiv.appendChild(thinkingElement);
                // outputDiv.scrollTop = outputDiv.scrollHeight;

                promptLine.style.visibility = 'hidden'; // Hide prompt

                fetch('/random_psalm')
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(errData => {
                                throw new Error(errData.error || `Server error: ${response.status}`);
                            }).catch(() => {
                                throw new Error(`Server error: ${response.status}`);
                            });
                        }
                        return response.json();
                    })
                    .then(data => {
                        const psalmText = data.response || "Could not retrieve a Psalm at this moment.";
                        // The 'score' from /random_psalm is null, typeResponse handles it gracefully
                        typeResponse(psalmText, outputDiv, data.score, () => {
                            outputDiv.appendChild(document.createElement('br'));
                            promptLine.style.visibility = 'visible';
                            ensureScrolling();
                            commandInput.focus(); // Keep focus on input for subsequent user interaction
                            updateCursorPosition();
                        });
                    })
                    .catch(error => {
                        console.error('Error fetching random Psalm:', error);
                        const errorElement = document.createElement('div');
                        errorElement.textContent = `Error: Could not load a Psalm. ${error.message}`;
                        errorElement.style.color = 'red'; // Or some other error indication
                        outputDiv.appendChild(errorElement);
                        outputDiv.appendChild(document.createElement('br'));
                        promptLine.style.visibility = 'visible';
                        ensureScrolling();
                        commandInput.focus();
                        updateCursorPosition();
                    });
            }

            function resetIdleTimer() {
                if (hasPsalmBeenShown) {
                    return; // Don't restart timer if Psalm has already been shown.
                }
                clearTimeout(idleTimerId); // Always clear any existing timer first.

                // Conditions for the timer to be active:
                const inputIsEmpty = commandInput.value.trim() === '';
                const inputIsActive = document.activeElement === commandInput;
                const UIIsReadyForInput = promptLine.style.visibility !== 'hidden';

                if (inputIsEmpty && inputIsActive && UIIsReadyForInput) {
                    idleTimerId = setTimeout(showRandomPsalm, idleTimeoutDuration);
                }
                // If conditions are not met, the timer remains cleared.
            }

            // Start the initial idle timer
            resetIdleTimer();

            // Listener specifically for Enter key
            commandInput.addEventListener('keydown', function(event) {
                // Note: resetIdleTimer() is NOT called here for all keys.
                // That is handled by 'input', 'focus', 'blur', 'click', and 'keyup' for navigation keys.

                if (event.key === 'Enter') {
                    clearTimeout(idleTimerId); // Stop timer: Enter is an explicit user action.
                    event.preventDefault();
                    const command = commandInput.value.trim();
                    if (command) {
                        // Display command in output
                        const commandElement = document.createElement('div');
                        commandElement.className = 'echoed-command-line'; // Add class for flex styling
                        commandElement.innerHTML = `<span class="username-echo">seeker</span><span class="prompt-echo">&gt;</span><span class="echoed-command-text">${escapeHtml(command)}</span>`;
                        outputDiv.appendChild(commandElement);
                        ensureScrolling();

                        // Hide the entire prompt line during response typing
                        promptLine.style.visibility = 'hidden';

                        fetch('/query', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ query: command }),
                        })
                        .then(response => {
                            if (!response.ok) {
                                // Try to parse error from backend if available, then throw
                                return response.json().then(errData => {
                                    throw new Error(errData.error || `Server error: ${response.status}`);
                                }).catch(() => {
                                    // Fallback if error response is not JSON or no 'error' field
                                    throw new Error(`Server error: ${response.status}`);
                                });
                            }
                            return response.json();
                        })
                        .then(data => {
                            const responseText = data.response || "Received no specific response.";
                            const score = data.score; // Get the score from the response
                            typeResponse(responseText, outputDiv, score, () => { // Pass score to typeResponse
                                // This callback runs after typing is complete
                                outputDiv.appendChild(document.createElement('br'));
                                commandInput.value = '';
                                promptLine.style.visibility = 'visible';
                                ensureScrolling();
                                commandInput.focus();
                                updateCursorPosition();
                            });
                        })
                        .catch(error => {
                            console.error('Fetch Error:', error);
                            const errorText = `Error: ${escapeHtml(error.message)}`;
                            // Errors don't have a score, or we can pass a default like null/0
                            typeResponse(errorText, outputDiv, null, () => {
                                // This callback runs after typing is complete
                                outputDiv.appendChild(document.createElement('br'));
                                commandInput.value = '';
                                promptLine.style.visibility = 'visible';
                                ensureScrolling();
                                commandInput.focus();
                                updateCursorPosition();
                            });
                        });
                    } else {
                        // Handle empty command: echo an empty prompt and add a line break
                        const commandElement = document.createElement('div');
                        commandElement.className = 'echoed-command-line'; // Also style empty command line
                        commandElement.innerHTML = `<span class="username-echo">seeker</span><span class="prompt-echo">&gt;</span>&nbsp;`; // Echo empty prompt with a non-breaking space
                        outputDiv.appendChild(commandElement);
                        outputDiv.appendChild(document.createElement('br')); // Add a line break
                        ensureScrolling();

                        commandInput.value = ''; // Ensure it's cleared
                        // outputDiv.scrollTop = outputDiv.scrollHeight; // Replaced by ensureScrolling
                        commandInput.focus(); // Keep focus on input
                        updateCursorPosition(); // Explicitly update cursor after clearing and focusing
                    }
                }
            });

            function typeResponse(text, container, score, callback) { // Added score parameter
                const baseResponseElement = document.createElement('div');
                baseResponseElement.className = 'llm-response-text'; // Default class

                if (score === 20) {
                    baseResponseElement.classList.add('perfect-score-text'); // Add class for perfect score
                }
                container.appendChild(baseResponseElement);

                let currentTargetElement = baseResponseElement; // Element to append to
                let i = 0;
                const typingSpeed = 30; // Milliseconds per character (adjust for desired speed)

                function typeChar() {
                    if (i < text.length) {
                        let charToAdd = text.charAt(i);
                        let consumedLength = 1;

                        const divineSpanOpenStr = '<span class="divine-name">';
                        const divineSpanCloseStr = '</span>';

                        if (charToAdd === '<' && text.substring(i).startsWith(divineSpanOpenStr)) {
                            const newSpan = document.createElement('span');
                            newSpan.className = 'divine-name';
                            currentTargetElement.appendChild(newSpan);
                            currentTargetElement = newSpan; // Future text goes into this span
                            consumedLength = divineSpanOpenStr.length;
                        } else if (charToAdd === '<' && text.substring(i).startsWith(divineSpanCloseStr)) {
                            if (currentTargetElement.parentElement && currentTargetElement.className === 'divine-name') {
                                currentTargetElement = currentTargetElement.parentElement; // Revert to parent
                            } else {
                                // Fallback or error: trying to close a span we're not in.
                                // For now, just append the literal string if structure is unexpected.
                                // This might happen if spans are malformed from backend.
                                baseResponseElement.innerHTML += divineSpanCloseStr;
                            }
                            consumedLength = divineSpanCloseStr.length;
                        } else {
                            // Append text (escaped) to the current target element
                            // If charToAdd is '<' or other special char not part of our tags, escape it.
                            currentTargetElement.appendChild(document.createTextNode(charToAdd));
                            // Note: escapeHtml was used with innerHTML. With textContent/createTextNode,
                            // browser handles escaping by default. If charToAdd is '<', it becomes literal '<'.
                            // If the original text from backend could have '&', it would become literal '&'.
                            // This is usually desired. If pre-escaped entities like &amp; are needed,
                            // then using innerHTML with escapeHtml for text nodes is more direct.
                            // For simplicity and safety with createTextNode, we'll add raw charToAdd.
                            // If HTML entities like &nbsp; are in the source text and need rendering,
                            // this approach would show them literally.
                            // The previous escapeHtml was fine for single chars.
                            // Let's stick to a simple model: if it's not our tag, it's text.
                            // If the text itself contains '<' or '&', createTextNode handles it.
                        }

                        i += consumedLength;
                        ensureScrolling(); // Scroll as text is typed
                        setTimeout(typeChar, typingSpeed);
                    } else {
                        // Typing finished
                        if (callback) {
                            callback();
                        }
                    }
                }
                typeChar(); // Start typing
            }

            function escapeHtml(unsafe) {
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

            // Focus on input when clicking anywhere in the terminal
            document.getElementById('terminal').addEventListener('click', (event) => {
                // If the click is on the input field itself, don't prevent default.
                // Otherwise, focus the input. This helps if user clicks on output area.
                if (event.target !== commandInput) {
                    commandInput.focus();
                }
            });

            // Also reset idle timer if user clicks in terminal (might not type but shows activity)
            document.getElementById('terminal').addEventListener('click', resetIdleTimer);

        });
    </script>
    <span id="textMeasurer"></span> <!-- Add the measurer span here -->
</body>
</html>
